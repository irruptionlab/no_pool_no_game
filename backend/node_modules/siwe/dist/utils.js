"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateNonce = exports.checkContractWalletSignature = void 0;
const random_1 = require("@stablelib/random");
const ethers_1 = require("ethers");
/**
 * This method calls the EIP-1271 method for Smart Contract wallets
 * @param message The EIP-4361 parsed message
 * @param provider Web3 provider able to perform a contract check (Web3/EthersJS).
 * @returns {Promise<boolean>} Checks for the smart contract (if it exists) if
 * the signature is valid for given address.
 */
const checkContractWalletSignature = (message, signature, provider) => __awaiter(void 0, void 0, void 0, function* () {
    if (!provider) {
        return false;
    }
    const abi = [
        'function isValidSignature(bytes32 _message, bytes _signature) public view returns (bool)',
    ];
    const walletContract = new ethers_1.Contract(message.address, abi, provider);
    const hashMessage = ethers_1.utils.hashMessage(message.prepareMessage());
    const isValidSignature = yield walletContract.isValidSignature(hashMessage, signature);
    return isValidSignature;
});
exports.checkContractWalletSignature = checkContractWalletSignature;
/**
 * This method leverages a native CSPRNG with support for both browser and Node.js
 * environments in order generate a cryptographically secure nonce for use in the
 * SiweMessage in order to prevent replay attacks.
 *
 * 96 bits has been chosen as a number to sufficiently balance size and security considerations
 * relative to the lifespan of it's usage.
 *
 * @returns cryptographically generated random nonce with 96 bits of entropy encoded with
 * an alphanumeric character set.
 */
const generateNonce = () => {
    return (0, random_1.randomStringForEntropy)(96);
};
exports.generateNonce = generateNonce;
